[[add-fleet-server-kubernetes]]
= Deploy Fleet Server on Kubernetes

[NOTE]
====
If your {stack} is orchestrated by {eck-ref}[ECK], we recommend to deploy the {fleet-server} through the operator. That simplifies the process, as the operator automatically handles most of the resources configuration and setup steps.

Refer to {eck-ref}/k8s-elastic-agent-fleet.html[Run Fleet-managed {agent} on ECK] for more information.
====

[IMPORTANT]
====
This guide assumes familiarity with Kubernetes concepts and resources, such as `Deployments`, `Pods`, `Secrets`, or `Services`, as well as configuring applications in Kubernetes environments.
====

To use {fleet} for central management, a <<fleet-server,{fleet-server}>> must
be running and accessible to your hosts.

You can deploy {fleet-server} on Kubernetes and manage it yourself.
In this deployment model, you are responsible for high-availability,
fault-tolerance, and lifecycle management of the {fleet-server}.

To deploy a {fleet-server} on Kubernetes and register it into Fleet you will need the following details:

* The *Policy ID* of a Fleet policy configured with the {fleet-server} integration.
* A *Service token*, used to authenticate Fleet Server with Elasticsearch.
* For outgoing traffic:
** The *{es} endpoint URL* where the {fleet-server} should connect to, configured also in the {es} output associated to the policy.
** When a private or intermediate Certificate Authority (CA) is used to sign the {es} certificate, the *{es} CA file* or the *CA fingerprint*, configured also in the {es} output associated to the policy.
* For incoming connections:
** A *TLS/SSL certificate and key* for the {fleet-server} HTTPS endpoint, used to encrypt the traffic from the {agent}s. This certificate has to be valid for the *{fleet-server} Host URL* that {agent}s use when connecting to the {fleet-server}.
* Extra TLS/SSL certificates and configuration parameters in case of requiring <<mutual-tls,mutual TLS>> (not covered in this document).

This document walks you through the complete setup process, organized into the following sections:

* <<add-fleet-server-kubernetes-compatibility,Compatibility requirements>>
* <<add-fleet-server-kubernetes-cert-prereq>>
* <<add-fleet-server-kubernetes-preparations>>
* <<add-fleet-server-kubernetes-install>>

[discrete]
[[add-fleet-server-kubernetes-compatibility]]
= Compatibility

{fleet-server} is compatible with the following Elastic products:

* {stack} 7.13 or later.
** For version compatibility: {es} >= {fleet-server} >= {agent} (except for
bugfix releases)
** {kib} should be on the same minor version as {es}.

[discrete]
[[add-fleet-server-kubernetes-prereq]]
= Prerequisites

Before deploying {fleet-server}, you need to:

* Prepare the SSL/TLS configuration, server certificate, <<fleet-server-hosts-setting>>, and needed Certificate Authorities (CAs).
* Ensure components have access to the ports needed for communication.

[discrete]
[[add-fleet-server-kubernetes-cert-prereq]]
== {fleet-server} and SSL/TLS certificates considerations

This section shows the minimum requirements in terms of Transport Layer Security (TLS) certificates for the {fleet-server}, assuming no mutual TLS (mTLS) is needed. Refer to <<tls-overview>> and <<mutual-tls>> for more information about the configuration needs of both approaches.

There are two main and differentiated traffic flows associated with the {fleet-server}, where each of them has different TLS needs:

[discrete]
[[add-fleet-server-kubernetes-cert-inbound]]
=== [{agent} → {fleet-server}] inbound traffic flow

In this flow {fleet-server} acts as the server and {agent} acts as the client. Therefore, {fleet-server} requires a TLS certificate and key, and {agent} will need to trust the CA certificate used to sign the {fleet-server} certificate.

[NOTE]
====
A {fleet-server} certificate is not required when installing the server using the *Quick start* mode, but should always be used for *production* deployments. In *Quick start* mode, the {fleet-server} uses a self-signed certificate and the {agent}s have to be enrolled with the `--insecure` option.
====

If your organization already uses the {stack}, you may already have a CA certificate that could be used to generate the new cert for the {fleet-server}. If you do not have a CA certificate, you can read more about generating a CA and a server certificate for the {fleet-server} in <<generate-fleet-server-certs>>.

You also need to know and plan in advance the <<fleet-server-hosts-setting, hostname / URL>> that the {agent} clients will use to access the {fleet-server}, because the *hostname* part of the URL needs to be included in the server certificate as an `x.509 Subject Alternative Name (SAN)`. If you plan to make your {fleet-server} accessible through *multiple hostnames* or *FQDNs*, add all of them to the server certificate.

[discrete]
[[add-fleet-server-kubernetes-cert-outbound]]
=== [{fleet-server} → {es} output] outbound traffic flow

In this flow, {fleet-server} acts as the client and {es} acts as the HTTPS server. For the communication to succeed, {fleet-server} needs to trust the CA certificate used to sign the {es} certificate. If your {es} cluster uses certificates signed by a corporate CA or multiple intermediate CAs you will need to use them during the {fleet-server} setup.

[NOTE]
====
If your {es} cluster is on Elastic Cloud or if it uses a certificate signed by a public and known CA, you won't need the {es} CA during the setup.
====

In summary, you need:

* A *server certificate and key*, valid for the {fleet-server} URL. The CA used to sign this certificate will be needed by the {agent} clients, not by the {fleet-server} itself.

* The *CA certificate* (or certificates) associated to your {es} cluster, except if you are sure your {es} certificate is fully trusted publicly.

[discrete]
[[default-port-assignments-kubernetes]]
== Default port assignments

When {es} or {fleet-server} are deployed, components communicate over well-defined, pre-allocated ports.
You may need to allow access to these ports. Refer to the following table for default port assignments:

|===
| Component communication | Default port
| {agent} → {fleet-server} | 8220
| {fleet-server} → {es} | 9200
| {fleet-server} → {kib} (optional, for {fleet} setup) | 5601
| {agent} → {es} | 9200
| {agent} → Logstash | 5044
| {agent} → {kib} (optional, for {fleet} setup) | 5601
|===

In Kubernetes environments, you can adapt these ports without modifying the listening ports of the {fleet-server} or other applications, as traffic is managed by Kubernetes `Services`. This guide includes an example where {agent}s connect to the {fleet-server} through port `443` instead of the default `8220`.

[discrete]
[[add-fleet-server-kubernetes-add-server]]
= Add {fleet-server}

A {fleet-server} is an {agent} that is enrolled in a {fleet-server} policy. The policy configures the agent to operate in a special mode to serve as a Fleet Server in your deployment.

[discrete]
[[add-fleet-server-kubernetes-preparations]]
== Fleet preparations

[TIP]
====
If you already have a Fleet policy with the {fleet-server} integration, you know its ID, and you know how to generate an {ref}/service-tokens-command.html[{es} service token] for the {fleet-server}, skip directly to <<add-fleet-server-kubernetes-install>>.

Also note that the `service token` required by the {fleet-server} is different from the `enrollment tokens` used by {agent}s to enroll to Fleet.
====

. In {kib}, open *Fleet → Settings* and ensure the *Elasticsearch output* that will be used by the {fleet-server} policy is correctly configured, paying special attention that:
+
** The *hosts* field includes a valid URL that will be reachable by the {fleet-server} Pod.
** If your {es} cluster uses certificates signed by private or intermediate CAs not publicly trusted, you have added the trust information in the *Elasticsearch CA trusted fingerprint* field or in the *advanced configuration* section through the `ssl.certificate_authorities` setting. For details, refer to the https://elastic.co/guide/en/fleet/current/secure-connections.html#_encrypt_traffic_between_elastic_agents_fleet_server_and_elasticsearch[Secure Connections] documentation.
+
[IMPORTANT]
====
This validation step is critical. The {es} host URL and CA information has to be added *in both the {es} output and the environment variables* provided to the {fleet-server} in a later step. It's a common mistake to ignore the output settings believing that the environment variables will prevail, when the environment variables are only used during the bootstrap of the {fleet-server}.

If the URL that {fleet-server} will use to access {es} is different from the {es} URL used by other clients, you may want to create a dedicated *{es} output* for {fleet-server}.
====

. Go to *Fleet → Agent Policies* and select *Create agent policy* to create a policy for the {fleet-server}:
+
** Set a *name* to the policy, for example `Fleet Server Policy Kubernetes`
** Do *not* select the option *collect system logs and metrics*. This option would add the `system integration` to the policy, and considering the {fleet-server} will run as a Kubernetes Pod without any visibility to the Kubernetes node, there won't be any real system to monitor.
** Select the **output** that the {fleet-server} needs to use to contact {es}. This should be the output that you verified in the previous step.
** If desired, add an **inactive agent unenrollment timeout** to automatically unenroll and invalidate API Keys after being inactive. This is useful on Kubernetes environments as the {fleet-server} Pods are ephemeral, and after restarts new {agent}s will appear in Fleet UI.

. Open the created policy, and from the *Integrations* tab select *Add integration*:
+
** Search and select the Fleet Server integration
** Select *Add Fleet Server* to add the integration to the policy.
+
At this point you can configure the integration settings per <<fleet-server-scalability>>.
** When done, select on *Save and continue*. Do not add any {agent} at this stage.

. Open the configured policy, which now includes the Fleet Server integration, and select *Actions* → *Add Fleet Server*. In the next dialog:
+
* Confirm that the *policy for Fleet Server* is properly selected.
* *Choose a deployment mode for security*:
** If you select *Quick start*, the {fleet-server} generates a `self-signed` TLS certificate, and subsequent agents should be enrolled using the `--insecure` flag.
** If you select *Production*, you provide a certificate and key to the {fleet-server} during the deployment, and subsequent agents will need to trust the certificate's CA.
* Add your *Fleet Server Host* information:
** This will be the URL used by the clients ({agent}s) to connect to the {fleet-server}. In *Production* mode, the {fleet-server} certificate must include the hostname part of the URL as an `x509 SAN`.
** On Kubernetes environments this could be the name of the `Kubernetes service` or reverse proxy that exposes the {fleet-server} Pods.
** This setting is not used by the {fleet-server} itself, so don't worry about it at this stage because you will be able to change it later on under *Fleet → Settings*.
* Select **generate service token** to create a token for the {fleet-server}.
* From *Install Fleet Server to a centralized host → Linux*, take note of the values of the following settings that will be needed for the {fleet-server} installation:
** Service token(under `--fleet-server-service-token` parameter).
** Fleet policy ID (under `--fleet-server-policy` parameter).
** {es} URL (under `--fleet-server-es` parameter).

. Keep the {kib} browser window open and continue with the <<add-fleet-server-kubernetes-install>>.
+
When the {fleet-server} installation has succeeded, the *Confirm Connection* UI will show a *Connected* status.

[discrete]
[[add-fleet-server-kubernetes-install]]
== Fleet Server installation

To deploy {fleet-server} on Kubernetes and enroll it into {fleet} you need the following details:

* *Policy ID* of the Fleet policy configured with the {fleet-server} integration.
* *Service token*, that you can generate following the <<add-fleet-server-kubernetes-preparations>> or manually using the {ref}/service-tokens-command.html[{es}-service-tokens command].
* *{es} endpoint URL*, configured also in the {es} output associated to the policy.
* *{es} CA certificate file*, configured also in the {es} output associated to the policy.
* {fleet-server} *certificate and key* (for *Production* deployment mode only).

If you followed the <<add-fleet-server-kubernetes-cert-prereq>> and <<add-fleet-server-kubernetes-preparations>> you should have everything ready to proceed with the {fleet-server} installation.

The suggested deployment method for the {fleet-server} consists of:

* A basic Kubernetes `Deployment` manifest that relies on two `Secrets` for its configuration.
* A `Secret` named `fleet-server-config` with the values for different environment variables.
* A `Secret` named `fleet-server-certs` with the certificate files and the {es} CA file needed for the installation.

Adapt and change the suggested manifests and deployment strategy to your needs, ensuring you feed the {fleet-server} with the needed configuration and certificates. For example, you can customize:

* Scheduling configuration, such as `affinity rules` or `tolerations`, if needed in your environment.
* CPU and memory resources configuration.
* Replicas for the Deployment (defaults to `1`).
* Namespace.
* Use an {es} CA fingerprint instead of a CA file.

[discrete]
[[add-fleet-server-kubernetes-install-steps]]
=== Installation Steps

. Create the `Secret` for the {fleet-server} configuration:
+
[source, shell]
------------------------------------------------------------
kubectl create secret generic fleet-server-config \
--from-literal=elastic_endpoint='YOUR_ELASTICSEARCH_HOST_URL' \ <1>
--from-literal=elastic_service_token='YOUR_SERVICE_TOKEN' \ <2>
--from-literal=fleet_policy_id='YOUR_POLICY_ID' <3>
------------------------------------------------------------
<1> The URL of your {es} host. For example `'https://monitoring-es-http.default.svc:9200'`.
<2> The service token provided by {kib} in the Fleet UI.
<3> The ID of the created policy. For example `'dee949ac-403c-4c83-a489-0122281e4253'`.
+
If you prefer to obtain a *yaml manifest* of the Secret to create, append `--dry-run=client -o=yaml` to the command and save the output to a file.

. Create the `Secret` with the TLS/SSL certificates:
+
++++
<div class="tabs" data-tab-group="fleet-k8s">
  <div role="tablist" aria-label="Fleet Server on Kubernetes">
    <button role="tab"
            aria-selected="true"
            aria-controls="quickstart-tab"
            id="quickstart">
      Quick start
    </button>
    <button role="tab"
            aria-selected="false"
            aria-controls="production-tab"
            id="production"
            tabindex="-1">
      Production
    </button>
  </div>
  <div tabindex="0"
       role="tabpanel"
       id="quickstart-tab"
       aria-labelledby="quickstart">
++++
+
include::add-fleet-server-kubernetes-content.asciidoc[tag=quickstart-secret]
+
++++
  </div>
  <div tabindex="0"
       role="tabpanel"
       id="production-tab"
       aria-labelledby="production"
       hidden="">
++++
+
include::add-fleet-server-kubernetes-content.asciidoc[tag=production-secret]
+
++++
  </div>
</div>
++++

. Save the proposed `Deployment` manifest locally, for example as `fleet-server-dep.yaml`, and adapt it to your needs:
+
++++
<div class="tabs" data-tab-group="fleet-k8s">
  <div role="tablist" aria-label="Fleet Server on Kubernetes">
    <button role="tab"
            aria-selected="true"
            aria-controls="quickstart-dep-tab"
            id="quickstart-dep">
      Quick start
    </button>
    <button role="tab"
            aria-selected="false"
            aria-controls="production-dep-tab"
            id="production-dep"
            tabindex="-1">
      Production
    </button>
  </div>
  <div tabindex="0"
       role="tabpanel"
       id="quickstart-dep-tab"
       aria-labelledby="quickstart-dep">
++++
+
include::add-fleet-server-kubernetes-content.asciidoc[tag=quickstart-deployment]
+
++++
  </div>
  <div tabindex="0"
       role="tabpanel"
       id="production-dep-tab"
       aria-labelledby="production-dep"
       hidden="">
++++
+
include::add-fleet-server-kubernetes-content.asciidoc[tag=production-deployment]
+
++++
  </div>
</div>
++++

. Deploy the configured manifest to create and start the {fleet-server}:
+
[source, shell]
------------------------------------------------------------
kubectl apply -f fleet-server-dep.yaml
------------------------------------------------------------
+
[IMPORTANT]
====
Ensure the `Deployment` and all referenced `Secrets` are created in the same `Namespace`.
====

. Check the {fleet-server} Pod logs for errors and confirm in {kib} that the {fleet-server} agent appears as `Connected` and `Healthy` in *{kib} → Fleet*.
+
[source, shell]
------------------------------------------------------------
kubectl logs fleet-server-xxxxx
------------------------------------------------------------
+
It can take a couple of minutes for {fleet-server} to fully start. If you left the {kib} browser window open during <<add-fleet-server-kubernetes-preparations>> it will show *Connected* when everything has gone well.
+
Do not continue with the next steps if the {fleet-server} is not completely up and healthy, and appearing in {fleet} UI.

. Expose the {fleet-server} to {agent}s through the *Fleet Server Host*:
+
This may include the creation of a Kubernetes `service`, an `ingress` resource, or DNS registers for FQDNs resolution. There are multiple ways to expose applications in Kubernetes.
+
The following example exposes the {fleet-server} with a `LoadBalancer` service, which will make the {fleet-server} available for both internal and external clients. Consider creating a `ClusterIP` instead of a `LoadBalancer` service if you only need to expose the {fleet-server} to {agent}s running in the same Kubernetes cluster.
+
[source, shell]
------------------------------------------------------------
kubectl expose deployment fleet-server --name fleet-svc --type LoadBalancer --port 443 --target-port 8220
------------------------------------------------------------
+
The previous example creates a service named `fleet-svc`, listening on port `443` and forwarding the traffic to the `fleet-server` deployment's Pods on port `8220`. The listening `--port` of the service can be customized, but the `--target-port` must remain on the default port (`8220`), because it's the port used by the {fleet-server} application.
+
The URL(s) that the clients would use to access the {fleet-server} in this example could be:
+
* For {agent}s within the Kubernetes cluster: `https://fleet-svc.<namespace>.svc`.
* For external {agent}s: access through the FQDN that was added on the DNS server pointing to the public IP of the `LoadBalancer`.
+
If your environment requires the {fleet-server} to be reachable through multiple hostnames or URLs, you can create multiple *Fleet Server Hosts* in *Fleet → Settings*, and create different policies for different groups of agents.
+
Remember that in *Production* mode, the *hostnames* used to access the {fleet-server} must be part of the server certificate as `x.509 Subject Alternative Names`.

[discrete]
[[add-fleet-server-kubernetes-troubleshoot]]
= Troubleshooting

[discrete]
[[add-fleet-server-kubernetes-troubleshoot-common]]
== Common Problems

The following issues may occur when {fleet-server} settings are missing or configured incorrectly:

* {fleet-server} is trying to access {es} at `localhost:9200` even though the `FLEET_SERVER_ELASTICSEARCH_HOST` environment variable is properly set.
+
This problem occurs when the `output` of the policy associated to the {fleet-server} is not correctly configured.

* TLS certificate trust issues occur even when the `ELASTICSEARCH_CA` environment variable is properly set during deployment.
+
This problem occurs when the `output` of the policy associated to the {fleet-server} is not correctly configured. Add the *CA certificate* or *CA trusted fingerprint* to the {es} output associated to the {fleet-server} policy.

[discrete]
[[add-fleet-server-kubernetes-troubleshoot-other]]
== Other issues

If you're unable to add a {fleet}-managed agent, click the **Agents** tab
and confirm that the agent running {fleet-server} is healthy.

[discrete]
[[add-fleet-server-kubernetes-next]]
= Next steps

Now you're ready to add {agent}s to your host systems.
To learn how, refer to <<install-fleet-managed-elastic-agent>>, or <<running-on-kubernetes-managed-by-fleet>> if your {agent}s will also run on Kubernetes.

When you connect {agent}s to {fleet-server}, remember to use the `--insecure` flag if the *quick start* mode was used, or to provide to the {agent}s the CA certificate associated to the {fleet-server} certificate if *production* mode was used.